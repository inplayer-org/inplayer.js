<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>examples\js\inplayer.js - InPlayer SDK</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
            InPlayer SDK
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.1.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Asset", "classes/InPlayer", "classes/Misc", "classes/Payment", "classes/Subscriptions", "classes/User"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Asset.html">Asset</a></li>
                <li><a href="../classes/InPlayer.html">InPlayer</a></li>
                <li><a href="../classes/Misc.html">Misc</a></li>
                <li><a href="../classes/Payment.html">Payment</a></li>
                <li><a href="../classes/Subscriptions.html">Subscriptions</a></li>
                <li><a href="../classes/User.html">User</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>examples\js\inplayer.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
(function (global, factory) {
	typeof exports === &#x27;object&#x27; &amp;&amp; typeof module !== &#x27;undefined&#x27; ? module.exports = factory(require(&#x27;net&#x27;), require(&#x27;websocket&#x27;)) :
	typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;net&#x27;, &#x27;websocket&#x27;], factory) :
	(global.InPlayer = factory(global.net,global.websocket));
}(this, (function (net,websocket) { &#x27;use strict&#x27;;

net = net &amp;&amp; net.hasOwnProperty(&#x27;default&#x27;) ? net[&#x27;default&#x27;] : net;
websocket = websocket &amp;&amp; websocket.hasOwnProperty(&#x27;default&#x27;) ? websocket[&#x27;default&#x27;] : websocket;

function __async(g) {
  return new Promise(function (s, j) {
    function c(a, x) {
      try {
        var r = g[x ? &quot;throw&quot; : &quot;next&quot;](a);
      } catch (e) {
        j(e);return;
      }r.done ? s(r.value) : Promise.resolve(r.value).then(c, d);
    }function d(e) {
      c(e, 1);
    }c();
  });
}

var commonjsGlobal = typeof window !== &#x27;undefined&#x27; ? window : typeof global !== &#x27;undefined&#x27; ? global : typeof self !== &#x27;undefined&#x27; ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var js_cookie = createCommonjsModule(function (module, exports) {
/*!
 * JavaScript Cookie v2.2.0
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl &amp; Fagner Brack
 * Released under the MIT license
 */
(function (factory) {
	var registeredInModuleLoader = false;
	if (typeof undefined === &#x27;function&#x27; &amp;&amp; undefined.amd) {
		undefined(factory);
		registeredInModuleLoader = true;
	}
	{
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var arguments$1 = arguments;

		var i = 0;
		var result = {};
		for (; i &lt; arguments.length; i++) {
			var attributes = arguments$1[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function init (converter) {
		function api (key, value, attributes) {
			var this$1 = this;

			var result;
			if (typeof document === &#x27;undefined&#x27;) {
				return;
			}

			// Write

			if (arguments.length &gt; 1) {
				attributes = extend({
					path: &#x27;/&#x27;
				}, api.defaults, attributes);

				if (typeof attributes.expires === &#x27;number&#x27;) {
					var expires = new Date();
					expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
					attributes.expires = expires;
				}

				// We&#x27;re using &quot;expires&quot; because &quot;max-age&quot; is not supported by IE
				attributes.expires = attributes.expires ? attributes.expires.toUTCString() : &#x27;&#x27;;

				try {
					result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				if (!converter.write) {
					value = encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
				} else {
					value = converter.write(value, key);
				}

				key = encodeURIComponent(String(key));
				key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
				key = key.replace(/[\(\)]/g, escape);

				var stringifiedAttributes = &#x27;&#x27;;

				for (var attributeName in attributes) {
					if (!attributes[attributeName]) {
						continue;
					}
					stringifiedAttributes += &#x27;; &#x27; + attributeName;
					if (attributes[attributeName] === true) {
						continue;
					}
					stringifiedAttributes += &#x27;=&#x27; + attributes[attributeName];
				}
				return (document.cookie = key + &#x27;=&#x27; + value + stringifiedAttributes);
			}

			// Read

			if (!key) {
				result = {};
			}

			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling &quot;get()&quot;
			var cookies = document.cookie ? document.cookie.split(&#x27;; &#x27;) : [];
			var rdecode = /(%[0-9A-Z]{2})+/g;
			var i = 0;

			for (; i &lt; cookies.length; i++) {
				var parts = cookies[i].split(&#x27;=&#x27;);
				var cookie = parts.slice(1).join(&#x27;=&#x27;);

				if (!this$1.json &amp;&amp; cookie.charAt(0) === &#x27;&quot;&#x27;) {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = parts[0].replace(rdecode, decodeURIComponent);
					cookie = converter.read ?
						converter.read(cookie, name) : converter(cookie, name) ||
						cookie.replace(rdecode, decodeURIComponent);

					if (this$1.json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					if (key === name) {
						result = cookie;
						break;
					}

					if (!key) {
						result[name] = cookie;
					}
				} catch (e) {}
			}

			return result;
		}

		api.set = api;
		api.get = function (key) {
			return api.call(api, key);
		};
		api.getJSON = function () {
			return api.apply({
				json: true
			}, [].slice.call(arguments));
		};
		api.defaults = {};

		api.remove = function (key, attributes) {
			api(key, &#x27;&#x27;, extend(attributes, {
				expires: -1
			}));
		};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));
});

var js_cookie_1 = js_cookie.get;
var js_cookie_2 = js_cookie.set;
var js_cookie_3 = js_cookie.remove;

var config = {
  BASE_URL: &#x27;https://staging-v2.inplayer.com&#x27;,
  INPLAYER_TOKEN_NAME: &#x27;inplayer_token&#x27;,
  &quot;stomp&quot;: {
    &quot;url&quot;: &quot;wss://staging-v2.inplayer.com:15671/ws&quot;,
    &quot;login&quot;: &quot;notifications&quot;,
    &quot;password&quot;: &quot;notifications&quot;
  }
};

var API = {
  //User
  signIn: ((config.BASE_URL) + &quot;/accounts/login&quot;),
  signOut: ((config.BASE_URL) + &quot;/accounts/logout&quot;),
  signUp: ((config.BASE_URL) + &quot;/accounts&quot;),
  requestNewPassword: ((config.BASE_URL) + &quot;/accounts/forgot-password&quot;),
  setNewPassword: function (token) { return ((config.BASE_URL) + &quot;/accounts/forgot-password/&quot; + token); },
  getAccountInfo: ((config.BASE_URL) + &quot;/accounts&quot;),
  social: function (state) { return ((config.BASE_URL) + &quot;/accounts/social?state=&quot; + state); },
  updateAccount: ((config.BASE_URL) + &quot;/accounts&quot;),
  changePassword: ((config.BASE_URL) + &quot;/accounts/change-password&quot;),
  getRegisterFields: function (merchant_uuid) { return ((config.BASE_URL) + &quot;/accounts/register-fields/&quot; + merchant_uuid); },
  //Asset
  checkAccess: function (id, multiple) {
    if ( multiple === void 0 ) multiple = false;

    return multiple ? ((config.BASE_URL) + &quot;/item/access?&quot; + id) : ((config.BASE_URL) + &quot;/items/&quot; + id + &quot;/access&quot;);
  },
  findAsset: function (assetId, merchant_uuid) { return ((config.BASE_URL) + &quot;/items/&quot; + merchant_uuid + &quot;/&quot; + assetId); },
  findExternalAsset: function (assetType, externalId) { return ((config.BASE_URL) + &quot;/items/assets/external/&quot; + assetType + &quot;/&quot; + externalId); },
  findPackage: function (id) { return ((config.BASE_URL) + &quot;/items/packages/&quot; + id); },
  findAccessFees: function (id) { return ((config.BASE_URL) + &quot;/items/&quot; + id + &quot;/access-fees&quot;); },
  freemium: ((config.BASE_URL) + &quot;/items/access/unlimited&quot;),
  //Payment
  getPaymentMethods: ((config.BASE_URL) + &quot;/payments/methods&quot;),
  getPaymentTools: function (paymentMethodId) { return ((config.BASE_URL) + &quot;/payments/method/&quot; + paymentMethodId + &quot;/tools&quot;); },
  payForAsset: ((config.BASE_URL) + &quot;/payments&quot;),
  externalPayments: ((config.BASE_URL) + &quot;/external-payments&quot;),
  //Subscriptions
  getSubscriptions: ((config.BASE_URL) + &quot;/subscriptions&quot;),
  subscribe: ((config.BASE_URL) + &quot;/subscriptions&quot;),
  //Misc
  getDlcLinks: function (id) { return ((config.BASE_URL) + &quot;/dlc/&quot; + id + &quot;/links&quot;); },
  getDiscount: ((config.BASE_URL) + &quot;/vouchers/discount&quot;),
  getBranding: function (merchant_uuid) { return ((config.BASE_URL) + &quot;/branding/paywall/&quot; + merchant_uuid); },
  downloadFile: function (assetId, filename) { return ((config.BASE_URL) + &quot;/dlc/&quot; + assetId + &quot;/&quot; + filename); }

};

var User = function User () {};

User.prototype.signIn = function signIn (data) {
  return __async(function* () {
    // Add into form data
    var fd = new FormData();
    fd.append(&#x27;email&#x27;, data.email);
    fd.append(&#x27;password&#x27;, data.password);
    fd.append(&#x27;merchant_uuid&#x27;, data.merchant_uuid);
    fd.append(&#x27;referrer&#x27;, data.referrer);
    // request
    try {
      var response = yield fetch(API.signIn, {
        method: &#x27;POST&#x27;,
        body: fd
      });

      var data$1 = yield response.json();

      /* set cookies */
      if (data$1.access_token) {
        js_cookie_2(config.INPLAYER_TOKEN_NAME, data$1.access_token);
      }

      return data$1;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Signs out the user and destroys cookies
 * @method signOut
 * @async
 * @example
 * InPlayer.User.signOut()
 * .then(data =&gt; console.log(data));
 * @return {Boolean}
*/
User.prototype.signOut = function signOut () {
  return __async(function* () {
    var token = js_cookie_1(config.INPLAYER_TOKEN_NAME);

    try {
      var response = yield fetch(API.signOut, {
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();
      // if response is okay
      if (data.explain) {
        js_cookie_3(config.INPLAYER_TOKEN_NAME);
      }
      return true;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Signs up/Registers user
 * @method signUp
 * @async
 * @param {Object} data - Contains {
 *full_name: string,
 *email: string
 *password: string,
 *password_confirmation: string,
 *merchant_uuid: string,
 *type: number
 *referrer: string,
 * }
 * @example
 * InPlayer.User.signUp({
 *full_name: &quot;test&quot;,
 *email: &quot;test32@test.com&quot;,
 *password: &quot;12345678&quot;,
 *password_confirmation: &quot;12345678&quot;,
 *merchant_uuid: &quot;528b1b80-5868-4abc-a9b6-4d3455d719c8&quot;,
 *type: &quot;consumer&quot;,
 *referrer: &quot;http://localhost:3000/&quot;,
 * })
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.signUp = function signUp (data) {
  return __async(function* () {

    // Add into form data
    var fd = new FormData();
    fd.append(&#x27;full_name&#x27;, data.full_name);
    fd.append(&#x27;email&#x27;, data.email);
    fd.append(&#x27;password&#x27;, data.password);
    fd.append(&#x27;password_confirmation&#x27;, data.password_confirmation);
    fd.append(&#x27;merchant_uuid&#x27;, data.merchant_uuid);
    fd.append(&#x27;type&#x27;, data.type);
    fd.append(&#x27;referrer&#x27;, data.referrer);

    try {
      var response = yield fetch(API.signUp, {
        method: &#x27;POST&#x27;,
        body: fd
      });

      var data$1 = yield response.json();

      return data$1;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Checks if user is signed in
 * @method isSignedIn
 * @example
 * InPlayer.User.isSignedIn()
 * @return {Boolean}
*/
User.prototype.isSignedIn = function isSignedIn () {
  return js_cookie_1(config.INPLAYER_TOKEN_NAME) !== undefined;
};

/**
 * Returns users Auth token
 * @method token
 * @example
 * InPlayer.User.token()
 * @return {String}
*/
User.prototype.token = function token () {
  return js_cookie_1(config.INPLAYER_TOKEN_NAME);
};

/**
 * Sets Auth token into cookies
 * @method token
 * @param {String} token - The Authorization token which needs to be set
 * @example
 * InPlayer.User.setTokenInCookie(&#x27;aed1g284i3dnfrfnd1o23rtegk&#x27;)
 * @return {void}
*/
User.prototype.setTokenInCookie = function setTokenInCookie (token) {
  js_cookie_2(config.INPLAYER_TOKEN_NAME, token);
};

/**
 * Requests new password for a given user
 * @method signUp
 * @async
 * @param {Object} data - Contains {
 *email: String,
 *merchant_uuid: string
 * }
 * @example
 * InPlayer.User.requestNewPassword({
 *email: &quot;test32@test.com&quot;,
 *merchant_uuid: &quot;528b1b80-5868-4abc-a9b6-4d3455d719c8&quot;,
 * })
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.requestNewPassword = function requestNewPassword (data) {
  return __async(function* () {

    // Add into from FormData
    var fd = new FormData();
    fd.append(&#x27;email&#x27;, data.email);
    fd.append(&#x27;merchant_uuid&#x27;, data.merchant_uuid);

    try {
      var response = yield fetch(API.requestNewPassword, {
        method: &#x27;POST&#x27;,
        body: fd
      });

      var data$1 = yield response.json();

      return data$1;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Sets new password for the user
 * @method setNewPassword
 * @async
 * @param {Object} data - Contains {
 *password: string
 *password_confirmation: string
 * }
 * @param {String} token - The authorization token
 * @example
 * InPlayer.User.setNewPassword({
 *password: &quot;12345&quot;,
 *password_confirmation: &quot;12345&quot;,
 * }, &#x27;afhqi83rji74hjf7e43df&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.setNewPassword = function setNewPassword (data, token) {
  return __async(function* () {

    var body = &quot;password=&quot; + (data.password) + &quot;&amp;password_confirmation=&quot; + (data.password_confirmation);

    try {
      var response = yield fetch(API.setNewPassword(token), {
        method: &#x27;PUT&#x27;,
        body: body,
        headers: {
          &#x27;Content-Type&#x27;: &#x27;x-www-form-urlencoded&#x27;
        }
      });

      var data$1 = yield response.json();

      return data$1;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Gets the user/account information for a given auth token
 * @method getAccountInfo
 * @async
 * @param {String} token - The authorization token
 * @example
 * InPlayer.User.getAccountInfo(&#x27;afhqi83rji74hjf7e43df&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.getAccountInfo = function getAccountInfo (token) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getAccountInfo, {
        method: &#x27;GET&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();
      if (data) { return data; }
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Gets the social login urls for fb/twitter/google
 * @method getSocialLoginUrls
 * @async
 * @param {String} state - The state for the social
 * @example
 * InPlayer.User.getSocialLoginUrls(&#x27;123124-1r-1r13ur1h1&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.getSocialLoginUrls = function getSocialLoginUrls (state) {
  return __async(function* () {
    try {
      var response = yield fetch(API.social(state), {
        method: &#x27;GET&#x27;
      });

      var data = yield response.json();

      if (data) { return data; }
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Updates the account info
 * @method updateAccount
 * @async
 * @param {Object} data - The new data for the account
 * @param {String} token - The authorization token
 * @example
 * InPlayer.User.updateAccount({},&#x27;123124-1r-1r13ur1h1&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.updateAccount = function updateAccount (data, token) {
  return __async(function* () {
    try {
      var response = yield fetch(API.updateAccount, {
        method: &#x27;PUT&#x27;,
        body: data,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token,
          &#x27;Content-Type&#x27;: &#x27;x-www-form-urlencoded&#x27;
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Changes password for a given user
 * @method changePassword
 * @async
 * @param {Object} data - Contains new password
 * @param {String} token - The authorization token
 * @example
 * InPlayer.User.updateAccount({},&#x27;123124-1r-1r13ur1h1&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.changePassword = function changePassword (data, token) {
  return __async(function* () {
    try {
      var response = yield fetch(API.changePassword, {
        method: &#x27;POST&#x27;,
        body: data,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Gets register fields
 * @method getRegisterFields
 * @async
 * @param {String} merchant_uuid - The merchant UUID
 * @example
 * InPlayer.User.getRegisterFields(&#x27;123124-1r-1r13ur1h1&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
User.prototype.getRegisterFields = function getRegisterFields (merchant_uuid) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getRegisterFields(merchant_uuid));

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

var Asset = function Asset () {};

Asset.prototype.checkAccessForAsset = function checkAccessForAsset (token, id) {
  return __async(function* () {
    try {
      var response = yield fetch(API.checkAccess(id), {
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Checks whether a given authenticated user has access for an array of assets
 * @method checkAccessForMultipleAssets
 * @async
 * @param {String} token - The Authorization token
 * @param {Array} ids - Array with asset ids
 * @example
 * InPlayer.Asset.checkAccessForMultipleAssets(&#x27;eyJ0eXAiOiJKPECENR5Y&#x27;,[36320,27215])
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Asset.prototype.checkAccessForMultipleAssets = function checkAccessForMultipleAssets (token, ids) {
  return __async(function* () {
    try {
      var response = yield fetch(API.checkAccess(ids, true), {
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Get the asset info for a given asset ID and merchant UUID
 * @method findAsset
 * @async
 * @param {Numer} assetId - The ID of the asset
 * @param {String} merchant_uuid - The merchant UUID string
 * @example
 * InPlayer.Asset.findAsset(2,&#x27;a1f13-dd1dfh-rfh123-dhd1hd-fahh1dl&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Asset.prototype.findAsset = function findAsset (assetId, merchant_uuid) {
  return __async(function* () {
    try {
      var response = yield fetch(API.findAsset(assetId, merchant_uuid), {
        method: &#x27;GET&#x27;
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Get an external assets&#x27; info
 * @method findExternalAsset
 * @async
 * @param {Numer} assetType - The type ID of the asset
 * @param {Number} externalId - The ID of the external asset
 * @example
 * InPlayer.Asset.findExternalAsset(2,44237)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Asset.prototype.findExternalAsset = function findExternalAsset (assetType, externalId) {
  return __async(function* () {
    try {
      var response = yield fetch(API.findExternalAsset(assetType, externalId), {
        method: &#x27;GET&#x27;
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Get package info for a given Package ID
 * @method findPackage
 * @async
 * @param {Numer} id - The type ID of the package
 * @example
 * InPlayer.Asset.findPackage(4444)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Asset.prototype.findPackage = function findPackage (id) {
  return __async(function* () {
    try {
      var response = yield fetch(API.findPackage(id), {
        method: &#x27;GET&#x27;
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Get the access fees for a given asset ID
 * @method getAssetAccessFees
 * @async
 * @param {Numer} id - The ID of the asset
 * @example
 * InPlayer.Asset.getAssetAccessFees(555)
 * .then(data =&gt; console.log(data))
 * @return {Object}
*/
Asset.prototype.getAssetAccessFees = function getAssetAccessFees (id) {
  return __async(function* () {
    try {
      var response = yield fetch(API.findAccessFees(id), {
        method: &#x27;GET&#x27;
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Get the freemium asset data
 * @method getAssetAccessFees
 * @async
 * @param {String} token - The authorization token
 * @param {Object} data - {}
 * @example
 * InPlayer.Asset.freemiumAsset(&#x27;uoifhadafefbad1312nfuqd123&#x27;, {})
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Asset.prototype.freemiumAsset = function freemiumAsset (token, data) {
  return __async(function* () {
    try {
      var response = yield fetch(API.freemium, {
        method: &#x27;POST&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        },
        body: data
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

var Payment = function Payment () {};

Payment.prototype.getPaymentMethods = function getPaymentMethods (token) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getPaymentMethods, {
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Get the payment tools for an aothorization token and payment method ID
 * @method getPaymentTools
 * @async
 * @param {String} token - The Authorization token
 * @param {Number} paymentMethodId - The Payment Method ID
 * @example
 * InPlayer.Payment.getPaymentTools(&#x27;dajh8ao8djadd2o8jh2ofkhdhqkgog3oj&#x27;, 2)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Payment.prototype.getPaymentTools = function getPaymentTools (token, paymentMethodId) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getPaymentTools(paymentMethodId), {
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Makes a Payment for a given Authorization token + asset/payment details
 * @method payForAsset
 * @async
 * @param {String} token - The Authorization token
 * @param {Object} data - Payment data
 * @example
 * // data.payment_method = { id.... }
 * InPlayer.Payment.getPaymentTools(&#x27;dajh8ao8djadd2o8jh2ofkhdhqkgog3oj&#x27;, {
 *number: 4111111111111111,
 *card_name: &#x27;PayPal&#x27;,
 *exp_month: 10,
 *exp_year: 2030,
 *cvv: 656,
 *access_fee: 2341,
 *payment_method: 1,
 *referrer: &#x27;http://google.com&#x27;
 * })
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Payment.prototype.payForAsset = function payForAsset (token, data) {
  return __async(function* () {
    try {
      var response = yield fetch(API.payForAsset, {
        method: &#x27;POST&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        },
        body: data
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Gets parameters for PayPal
 * @method getPayPalParams
 * @async
 * @param {String} token - The Authorization token
 * @param {Object} data - Contains details
 * @example
 * InPlayer.Payment.getPayPalParams(&#x27;dajh8ao8djadd2o8jh2ofkhdhqkgog3oj&#x27;, {})
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Payment.prototype.getPayPalParams = function getPayPalParams (token, data) {
  return __async(function* () {
    try {
      var response = yield fetch(API.externalPayments, {
        method: &#x27;POST&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        },
        body: data
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Contains all Requests connected with subscriptions
 *
 * @class Payment
 */
var Subscriptions = function Subscriptions () {};

Subscriptions.prototype.getSubscriptions = function getSubscriptions (token) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getSubscriptions, {
        method: &#x27;GET&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Cancels a subscription
 * @method cancelSubscription
 * @async
 * @param {String} unsubscribe_url - The url for the subscription which is getting unsubscribed
 * @param {String} token - The Authorization token
 * @example
 * InPlayer.Subscriptions.cancelSubscription(&#x27;http://localhost/subscription/1&#x27;,&#x27;eyJ0eXAiOiJKPECENR5Y&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Subscriptions.prototype.cancelSubscription = function cancelSubscription (unsubscribe_url, token) {
  return __async(function* () {
    try {
      var response = yield fetch(unsubscribe_url, {
        method: &#x27;GET&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Subscribes to a given asset
 * @method assetSubscribe
 * @async
 * @param {String} token - The Authorization token
 * @param {Object} data - {}
 * @example
 * InPlayer.Subscriptions.assetSubscribe(&#x27;eyJ0eXAiOiJKPECENR5Y&#x27;, {})
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Subscriptions.prototype.assetSubscribe = function assetSubscribe (token, data) {
  return __async(function* () {
    try {
      var response = yield fetch(API.subscribe, {
        method: &#x27;POST&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        },
        body: data
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

var Misc = function Misc () {};

Misc.prototype.getDlcLinks = function getDlcLinks (token, assetId) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getDlcLinks(assetId), {
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Gets the discount for a given ..
 * @method getDiscount
 * @async
 * @param {String} token - The Authorization token
 * @param {Object} data - {}
 * @example
 * InPlayer.Misc.getDiscount(&#x27;eyJ0eXAiOiJKPECENR5Y&#x27;,{})
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Misc.prototype.getDiscount = function getDiscount (token, data) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getDiscount, {
        method: &#x27;POST&#x27;,
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        },
        body: data
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Gets branding for given merchant
 * @method getBranding
 * @async
 * @param {String} merchant_uuid - The UUID of the merchant
 * @example
 * InPlayer.Misc.getBranding(&#x27;eyJ0e-XAiOi-JKPEC-ENR5Y&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Misc.prototype.getBranding = function getBranding (merchant_uuid) {
  return __async(function* () {
    try {
      var response = yield fetch(API.getBranding(merchant_uuid), {
        method: &#x27;GET&#x27;
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Downloads a file
 * @method downloadProtectedFile
 * @async
 * @param {String} token - The Authorization token
 * @param {number} assetId - The Id of the asset
 * @param {String} filename - The name of the file
 * @example
 * InPlayer.Misc.downloadProtectedFile(&#x27;eyJ0eXAiOiJKPECENR5Y&#x27;,2234, &#x27;test.js&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Misc.prototype.downloadProtectedFile = function downloadProtectedFile (token, assetId, filename) {
  return __async(function* () {
    try {
      var response = yield fetch(API.downloadFile(assetId, filename), {
        headers: {
          &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token
        }
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

/**
 * Fetches WP content
 * @method fetchWPContent
 * @async
 * @param {String} url - The url from where to fetch
 * @example
 * InPlayer.Misc.fetchWPContent(&#x27;http://localhost:3000&#x27;)
 * .then(data =&gt; console.log(data));
 * @return {Object}
*/
Misc.prototype.fetchWPContent = function fetchWPContent (url) {
  return __async(function* () {
    try {
      var response = yield fetch(url, {
        credentials: &#x27;same-origin&#x27;
      });

      var data = yield response.json();

      return data;
    } catch (error) {
      return false;
    }
  }());
};

var stomp = createCommonjsModule(function (module, exports) {
// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */

(function() {
  var Byte, Client, Frame, Stomp,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Byte = {
    LF: &#x27;\x0A&#x27;,
    NULL: &#x27;\x00&#x27;
  };

  Frame = (function() {
    var unmarshallSingle;

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : &#x27;&#x27;;
    }

    Frame.prototype.toString = function() {
      var lines, name, skipContentLength, value, _ref;
      lines = [this.command];
      skipContentLength = this.headers[&#x27;content-length&#x27;] === false ? true : false;
      if (skipContentLength) {
        delete this.headers[&#x27;content-length&#x27;];
      }
      _ref = this.headers;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) { continue; }
        value = _ref[name];
        lines.push(&quot;&quot; + name + &quot;:&quot; + value);
      }
      if (this.body &amp;&amp; !skipContentLength) {
        lines.push(&quot;content-length:&quot; + (Frame.sizeOfUTF8(this.body)));
      }
      lines.push(Byte.LF + this.body);
      return lines.join(Byte.LF);
    };

    Frame.sizeOfUTF8 = function(s) {
      if (s) {
        return encodeURI(s).match(/%..|./g).length;
      } else {
        return 0;
      }
    };

    unmarshallSingle = function(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;
      divider = data.search(RegExp(&quot;&quot; + Byte.LF + Byte.LF));
      headerLines = data.substring(0, divider).split(Byte.LF);
      command = headerLines.shift();
      headers = {};
      trim = function(str) {
        return str.replace(/^\s+|\s+$/g, &#x27;&#x27;);
      };
      _ref = headerLines.reverse();
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        line = _ref[_i];
        idx = line.indexOf(&#x27;:&#x27;);
        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
      }
      body = &#x27;&#x27;;
      start = divider + 2;
      if (headers[&#x27;content-length&#x27;]) {
        len = parseInt(headers[&#x27;content-length&#x27;]);
        body = (&#x27;&#x27; + data).substring(start, start + len);
      } else {
        chr = null;
        for (i = _j = start, _ref1 = data.length; start &lt;= _ref1 ? _j &lt; _ref1 : _j &gt; _ref1; i = start &lt;= _ref1 ? ++_j : --_j) {
          chr = data.charAt(i);
          if (chr === Byte.NULL) {
            break;
          }
          body += chr;
        }
      }
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function(datas) {
      var data;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = datas.split(RegExp(&quot;&quot; + Byte.NULL + Byte.LF + &quot;*&quot;));
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          data = _ref[_i];
          if ((data != null ? data.length : void 0) &gt; 0) {
            _results.push(unmarshallSingle(data));
          }
        }
        return _results;
      })();
    };

    Frame.marshall = function(command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + Byte.NULL;
    };

    return Frame;

  })();

  Client = (function() {
    var now;

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = &quot;arraybuffer&quot;;
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.maxWebSocketFrameSize = 16 * 1024;
      this.subscriptions = {};
    }

    Client.prototype.debug = function(message) {
      var _ref;
      return typeof window !== &quot;undefined&quot; &amp;&amp; window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;
    };

    now = function() {
      if (Date.now) {
        return Date.now();
      } else {
        return new Date().valueOf;
      }
    };

    Client.prototype._transmit = function(command, headers, body) {
      var this$1 = this;

      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === &quot;function&quot;) {
        this.debug(&quot;&gt;&gt;&gt; &quot; + out);
      }
      while (true) {
        if (out.length &gt; this$1.maxWebSocketFrameSize) {
          this$1.ws.send(out.substring(0, this$1.maxWebSocketFrameSize));
          out = out.substring(this$1.maxWebSocketFrameSize);
          if (typeof this$1.debug === &quot;function&quot;) {
            this$1.debug(&quot;remaining = &quot; + out.length);
          }
        } else {
          return this$1.ws.send(out);
        }
      }
    };

    Client.prototype._setupHeartbeat = function(headers) {
      var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1;
      if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 &amp;&amp; _ref !== Stomp.VERSIONS.V1_2) {
        return;
      }
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = headers[&#x27;heart-beat&#x27;].split(&quot;,&quot;);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i &lt; _len; _i++) {
          v = _ref1[_i];
          _results.push(parseInt(v));
        }
        return _results;
      })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
        if (typeof this.debug === &quot;function&quot;) {
          this.debug(&quot;send PING every &quot; + ttl + &quot;ms&quot;);
        }
        this.pinger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            _this.ws.send(Byte.LF);
            return typeof _this.debug === &quot;function&quot; ? _this.debug(&quot;&gt;&gt;&gt; PING&quot;) : void 0;
          };
        })(this));
      }
      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
        if (typeof this.debug === &quot;function&quot;) {
          this.debug(&quot;check PONG every &quot; + ttl + &quot;ms&quot;);
        }
        return this.ponger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            var delta;
            delta = now() - _this.serverActivity;
            if (delta &gt; ttl * 2) {
              if (typeof _this.debug === &quot;function&quot;) {
                _this.debug(&quot;did not receive server activity for the last &quot; + delta + &quot;ms&quot;);
              }
              return _this.ws.close();
            }
          };
        })(this));
      }
    };

    Client.prototype._parseConnect = function() {
      var args, connectCallback, errorCallback, headers;
      args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
      headers = {};
      switch (args.length) {
        case 2:
          headers = args[0], connectCallback = args[1];
          break;
        case 3:
          if (args[1] instanceof Function) {
            headers = args[0], connectCallback = args[1], errorCallback = args[2];
          } else {
            headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
          }
          break;
        case 4:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
          break;
        default:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
      }
      return [headers, connectCallback, errorCallback];
    };

    Client.prototype.connect = function() {
      var args, errorCallback, headers, out;
      args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
      out = this._parseConnect.apply(this, args);
      headers = out[0], this.connectCallback = out[1], errorCallback = out[2];
      if (typeof this.debug === &quot;function&quot;) {
        this.debug(&quot;Opening Web Socket...&quot;);
      }
      this.ws.onmessage = (function(_this) {
        return function(evt) {
          var arr, c, client, data, frame, messageID, onreceive, subscription, _i, _len, _ref, _results;
          data = typeof ArrayBuffer !== &#x27;undefined&#x27; &amp;&amp; evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === &quot;function&quot; ? _this.debug(&quot;--- got data length: &quot; + arr.length) : void 0, ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = arr.length; _i &lt; _len; _i++) {
              c = arr[_i];
              _results.push(String.fromCharCode(c));
            }
            return _results;
          })()).join(&#x27;&#x27;)) : evt.data;
          _this.serverActivity = now();
          if (data === Byte.LF) {
            if (typeof _this.debug === &quot;function&quot;) {
              _this.debug(&quot;&lt;&lt;&lt; PONG&quot;);
            }
            return;
          }
          if (typeof _this.debug === &quot;function&quot;) {
            _this.debug(&quot;&lt;&lt;&lt; &quot; + data);
          }
          _ref = Frame.unmarshall(data);
          _results = [];
          for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
            frame = _ref[_i];
            switch (frame.command) {
              case &quot;CONNECTED&quot;:
                if (typeof _this.debug === &quot;function&quot;) {
                  _this.debug(&quot;connected to server &quot; + frame.headers.server);
                }
                _this.connected = true;
                _this._setupHeartbeat(frame.headers);
                _results.push(typeof _this.connectCallback === &quot;function&quot; ? _this.connectCallback(frame) : void 0);
                break;
              case &quot;MESSAGE&quot;:
                subscription = frame.headers.subscription;
                onreceive = _this.subscriptions[subscription] || _this.onreceive;
                if (onreceive) {
                  client = _this;
                  messageID = frame.headers[&quot;message-id&quot;];
                  frame.ack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.ack(messageID, subscription, headers);
                  };
                  frame.nack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.nack(messageID, subscription, headers);
                  };
                  _results.push(onreceive(frame));
                } else {
                  _results.push(typeof _this.debug === &quot;function&quot; ? _this.debug(&quot;Unhandled received MESSAGE: &quot; + frame) : void 0);
                }
                break;
              case &quot;RECEIPT&quot;:
                _results.push(typeof _this.onreceipt === &quot;function&quot; ? _this.onreceipt(frame) : void 0);
                break;
              case &quot;ERROR&quot;:
                _results.push(typeof errorCallback === &quot;function&quot; ? errorCallback(frame) : void 0);
                break;
              default:
                _results.push(typeof _this.debug === &quot;function&quot; ? _this.debug(&quot;Unhandled frame: &quot; + frame) : void 0);
            }
          }
          return _results;
        };
      })(this);
      this.ws.onclose = (function(_this) {
        return function() {
          var msg;
          msg = &quot;Whoops! Lost connection to &quot; + _this.ws.url;
          if (typeof _this.debug === &quot;function&quot;) {
            _this.debug(msg);
          }
          _this._cleanUp();
          return typeof errorCallback === &quot;function&quot; ? errorCallback(msg) : void 0;
        };
      })(this);
      return this.ws.onopen = (function(_this) {
        return function() {
          if (typeof _this.debug === &quot;function&quot;) {
            _this.debug(&#x27;Web Socket Opened...&#x27;);
          }
          headers[&quot;accept-version&quot;] = Stomp.VERSIONS.supportedVersions();
          headers[&quot;heart-beat&quot;] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(&#x27;,&#x27;);
          return _this._transmit(&quot;CONNECT&quot;, headers);
        };
      })(this);
    };

    Client.prototype.disconnect = function(disconnectCallback, headers) {
      if (headers == null) {
        headers = {};
      }
      this._transmit(&quot;DISCONNECT&quot;, headers);
      this.ws.onclose = null;
      this.ws.close();
      this._cleanUp();
      return typeof disconnectCallback === &quot;function&quot; ? disconnectCallback() : void 0;
    };

    Client.prototype._cleanUp = function() {
      this.connected = false;
      if (this.pinger) {
        Stomp.clearInterval(this.pinger);
      }
      if (this.ponger) {
        return Stomp.clearInterval(this.ponger);
      }
    };

    Client.prototype.send = function(destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = &#x27;&#x27;;
      }
      headers.destination = destination;
      return this._transmit(&quot;SEND&quot;, headers, body);
    };

    Client.prototype.subscribe = function(destination, callback, headers) {
      var client;
      if (headers == null) {
        headers = {};
      }
      if (!headers.id) {
        headers.id = &quot;sub-&quot; + this.counter++;
      }
      headers.destination = destination;
      this.subscriptions[headers.id] = callback;
      this._transmit(&quot;SUBSCRIBE&quot;, headers);
      client = this;
      return {
        id: headers.id,
        unsubscribe: function() {
          return client.unsubscribe(headers.id);
        }
      };
    };

    Client.prototype.unsubscribe = function(id) {
      delete this.subscriptions[id];
      return this._transmit(&quot;UNSUBSCRIBE&quot;, {
        id: id
      });
    };

    Client.prototype.begin = function(transaction) {
      var client, txid;
      txid = transaction || &quot;tx-&quot; + this.counter++;
      this._transmit(&quot;BEGIN&quot;, {
        transaction: txid
      });
      client = this;
      return {
        id: txid,
        commit: function() {
          return client.commit(txid);
        },
        abort: function() {
          return client.abort(txid);
        }
      };
    };

    Client.prototype.commit = function(transaction) {
      return this._transmit(&quot;COMMIT&quot;, {
        transaction: transaction
      });
    };

    Client.prototype.abort = function(transaction) {
      return this._transmit(&quot;ABORT&quot;, {
        transaction: transaction
      });
    };

    Client.prototype.ack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers[&quot;message-id&quot;] = messageID;
      headers.subscription = subscription;
      return this._transmit(&quot;ACK&quot;, headers);
    };

    Client.prototype.nack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers[&quot;message-id&quot;] = messageID;
      headers.subscription = subscription;
      return this._transmit(&quot;NACK&quot;, headers);
    };

    return Client;

  })();

  Stomp = {
    VERSIONS: {
      V1_0: &#x27;1.0&#x27;,
      V1_1: &#x27;1.1&#x27;,
      V1_2: &#x27;1.2&#x27;,
      supportedVersions: function() {
        return &#x27;1.1,1.0&#x27;;
      }
    },
    client: function(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = [&#x27;v10.stomp&#x27;, &#x27;v11.stomp&#x27;];
      }
      klass = Stomp.WebSocketClass || WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function(ws) {
      return new Client(ws);
    },
    Frame: Frame
  };

  if (&#x27;object&#x27; !== &quot;undefined&quot; &amp;&amp; exports !== null) {
    exports.Stomp = Stomp;
  }

  if (typeof window !== &quot;undefined&quot; &amp;&amp; window !== null) {
    Stomp.setInterval = function(interval, f) {
      return window.setInterval(f, interval);
    };
    Stomp.clearInterval = function(id) {
      return window.clearInterval(id);
    };
    window.Stomp = Stomp;
  } else if (!exports) {
    self.Stomp = Stomp;
  }

}).call(commonjsGlobal);
});

var stomp_1 = stomp.Stomp;

var stompNode = createCommonjsModule(function (module, exports) {
// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2013 [Jeff Mesnil](http://jmesnil.net/)
 */

(function() {
  var Stomp, net$$1, overTCP, overWS, wrapTCP, wrapWS;

  Stomp = stomp;

  net$$1 = net;

  Stomp.Stomp.setInterval = function(interval, f) {
    return setInterval(f, interval);
  };

  Stomp.Stomp.clearInterval = function(id) {
    return clearInterval(id);
  };

  wrapTCP = function(port, host) {
    var socket, ws;
    socket = null;
    ws = {
      url: &#x27;tcp:// &#x27; + host + &#x27;:&#x27; + port,
      send: function(d) {
        return socket.write(d);
      },
      close: function() {
        return socket.end();
      }
    };
    socket = net$$1.connect(port, host, function(e) {
      return ws.onopen();
    });
    socket.on(&#x27;error&#x27;, function(e) {
      return typeof ws.onclose === &quot;function&quot; ? ws.onclose(e) : void 0;
    });
    socket.on(&#x27;close&#x27;, function(e) {
      return typeof ws.onclose === &quot;function&quot; ? ws.onclose(e) : void 0;
    });
    socket.on(&#x27;data&#x27;, function(data) {
      var event;
      event = {
        &#x27;data&#x27;: data.toString()
      };
      return ws.onmessage(event);
    });
    return ws;
  };

  wrapWS = function(url) {
    var WebSocketClient, connection, socket, ws;
    WebSocketClient = websocket.client;
    connection = null;
    ws = {
      url: url,
      send: function(d) {
        return connection.sendUTF(d);
      },
      close: function() {
        return connection.close();
      }
    };
    socket = new WebSocketClient();
    socket.on(&#x27;connect&#x27;, function(conn) {
      connection = conn;
      ws.onopen();
      connection.on(&#x27;error&#x27;, function(error) {
        return typeof ws.onclose === &quot;function&quot; ? ws.onclose(error) : void 0;
      });
      connection.on(&#x27;close&#x27;, function() {
        return typeof ws.onclose === &quot;function&quot; ? ws.onclose() : void 0;
      });
      return connection.on(&#x27;message&#x27;, function(message) {
        var event;
        if (message.type === &#x27;utf8&#x27;) {
          event = {
            &#x27;data&#x27;: message.utf8Data
          };
          return ws.onmessage(event);
        }
      });
    });
    socket.connect(url);
    return ws;
  };

  overTCP = function(host, port) {
    var socket;
    socket = wrapTCP(port, host);
    return Stomp.Stomp.over(socket);
  };

  overWS = function(url) {
    var socket;
    socket = wrapWS(url);
    return Stomp.Stomp.over(socket);
  };

  exports.overTCP = overTCP;

  exports.overWS = overWS;

}).call(commonjsGlobal);
});

var stompNode_1 = stompNode.overTCP;
var stompNode_2 = stompNode.overWS;

var stompjs = stomp.Stomp;
var overTCP = stompNode.overTCP;
var overWS = stompNode.overWS;

stompjs.overTCP = overTCP;
stompjs.overWS = overWS;

var Socket = function Socket() {
  this.subscription = null;
};

Socket.prototype.subscribe = function subscribe (account_uuid, callbackParams) {

  if (!account_uuid &amp;&amp; account_uuid !== &#x27;&#x27;) {
    return false;
  }

  if (callbackParams &amp;&amp; callbackParams.onmessage) {
    if (typeof callbackParams.onmessage !== &#x27;function&#x27;) {
      return false;
    }
  } else {
    callbackParams.onMessage = function (e) { return console.log(&#x27;Received message:&#x27;, e); };
  }

  if (callbackParams &amp;&amp; callbackParams.onopen) {
    if (typeof callbackParams.onopen !== &#x27;function&#x27;) {
      return false;
    }
  }

  var Socket = &quot;MozWebSocket&quot; in window ? MozWebSocket : WebSocket;

  var ws = new Socket(config.stomp.url);
  this.client = stompjs.over(ws);
  this.client.heartbeat.outgoing = 20000;
  this.client.heartbeat.incoming = 20000;
  this.client.debug = null;

  var parent = this;
  var uuid = account_uuid;

  this.client.connect({
    login: config.stomp.login,
    passcode: config.stomp.password,
    &#x27;client-id&#x27;: account_uuid }, function () {
    // call onopen callback
    if (callbackParams &amp;&amp; callbackParams.onopen) { callbackParams.onopen(); }

    // subscribe to events
    parent.client.subscribe(&#x27;/exchange/notifications/&#x27; + uuid, callbackParams.onmessage, {
      id: account_uuid,
      ack: &#x27;client&#x27;
    });

    // parent.setClient(client);
  }, function (frame) {
    if (typeof frame !== &#x27;string&#x27;) {
      console.warn(&#x27;Stomp error: &#x27;, frame);
    }
  });

  this.setClient(this.client);
};

Socket.prototype.setClient = function setClient (client) {
  this.subscription = client;
};
Socket.prototype.unsubscribe = function unsubscribe () {
  if (this.subscription &amp;&amp; this.subscription.connected) {
    this.subscription.unsubscribe();
  }
};

var InPlayer = function InPlayer() {
  this.User = new User();
  this.Asset = new Asset();
  this.Payment = new Payment();
  this.Subscriptions = new Subscriptions();
  this.Misc = new Misc();
  this.Socket = new Socket();
};

/**
 * Subscribes to websocket events
 * @method subscribe
 * @param {String} account_uuid - The users account UUID
 * @param {Object} callbackParams - Methods regarding websocket
 * {
 *onmessage: function,
 *onopen: function,
 *onclose: function
 * }
 * @example
 * InPlayer.subscribe(
 *&#x27;adsasd-d1-cjc1c-1ajaveo&#x27;, {
 *  onmessage: (message) =&gt; { let body = JSON.parse(message.body); console.log(body, &#x27;message&#x27;) },
 *  onopen: (e) =&gt; console.log(&#x27;open&#x27;),
 *  onclose: (e) =&gt; console.log(&#x27;close&#x27;, e)
 *}
 * )
 * @return {Boolean}
*/
InPlayer.prototype.subscribe = function subscribe (account_uuid, callbackParams) {
  if (this.User.isSignedIn()) {
    this.Socket.subscribe(account_uuid, callbackParams);
    return true;
  } else {
    return false;
  }
};

/**
 * Unsubscribes from the websocket and event listeners
 * @method unsubscribe
 * @example
 * InPlayer.unsubscribe()
 * @return {Boolean}
*/
InPlayer.prototype.unsubscribe = function unsubscribe () {
  this.Socket.unsubscribe();
};

var index = new InPlayer();

return index;

})));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
